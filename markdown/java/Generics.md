## Generics

<br>

다양한 타입의 객체를 다루는 메서드, 컬렉션 클래스에서 **컴파일 시에 타입 체크**

    Compile - 컴파일시 타입체크가 안전하다.
    
    Runtime - 동작 중에 오류 발생 가능 ex) instanceof

미리 사용할 타입을 명시해 형 변환을 하지 않아도 된다.

객체 타입에 대한 안전성 향상 및 형 변환의 번거로움 감소

<br>

### 표현

클래스 또는 인터페이스 선언 시 <>에 타입 파라미터 표시
```java
public class 클래스 이름<타입 파라미터> {}
public interface 인터페이스 이름<타입 파라미터> {}
```

<br>

###  타입 파라미터 (Type Parameter)

단순히 **임의의 참조형 타입**

컴파일 시 타입 파라미터들은 대입된 타입으로 대체된다.

- - -

- T : reference **T**ype
- E : **E**lement
- K : **K**ey
- V : **V**alue

<br>

### 객체 생성

변수와 생석 부분 타입은 반드시 같아야 한다.

<br>

```java
클래스 이름<String> generic = new 클래스 이름<String>();
클래스 이름<String> generic = new 클래스 이름<>();
클래스 이름 generic = new 클래스 이름(); // 타입 참조 필요 경고
```

<br><br>

### 타입 파리미터 제한

<br>

필요에 따라 구체적인 타입으로 제한 가능

제한하고자 하는 범위의 기준으로 `extends` 혹은 `super` 사용

인터페이스로 제한할 경우 `extends` 사용이 가능하다.

클래스와 인터페이스 제약 조건을 같이 사용할 경우 `&` 로 연결

<br>

```java
Generic type<?>             // 타입 제한 없음(Object)
Generic type<? extends T>   // T 또는 T를 상속받은 타입으로 제한
Generic type<? super T>     // T 또는 T의 조상 타입으로 제한
```

<br><br>

### 제네릭 메서드 (Generic method)

<br>

메서드의 파라미터와 리턴타입으로 타입 파라미터를 가지는 메서드

```java
접근제한자 <Type Parameter> 리턴타입 메서드이름(파라미터) {
    ...
}
```

tatic 변수에 제네릭을 사용하면 여러 인스턴스에서 어떤 타입으로 공유되어야할지 지정할 수 없어서 사용할 수 없습니다.

static 변수는 값 자체가 공유되기 때문입니다.

값 자체가 공유되려면 타입에 대한 정보도 있어야하기 때문에 static 변수에는 타입이 지정되지 않은 제네릭 타입은 사용하지 못합니다.

하지만, static 메서드는 메서드의 틀만 공유합니다.

즉, 제네릭 메서드를 정의할때는 리턴타입이 무엇인지와는 상관없이 내가 제네릭 메서드라는 것을 컴파일러에게 알려줘야합니다.

static 메서드는 메서드의 틀 안에서 지역변수처럼 타입 파라미터가 다양하게 오가는 형태로 사용될 수 있는 것입니다.