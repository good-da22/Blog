# DML
Data Manipulation Language, 개별적으로 database 테이블에서 새로운 행을 입력, 기존 행 변경, 제거
- INSERT
- UPDATE
- DELETE
- SELECT

# DDL
Data  Definition Language, 테이블로부터 데이터 구조를 생성, 변경, 제거
- CREATE
- ALTER
- DROP
- RENAME

# DCL
Data Control Language, database와 그 구조에 대한 접근 권한을 제공, 제거
- GRANT
- REVOKE

# 변경 관리
- COMMIT
- ROLLBACK

# 테이블 생성
```sql
CREATE TABLE table_name (
    column_name1 TYPE [optional attributes],
    column_name2 TYPE,
    ...
)
```

# optional attributes
- NOT NULL : 각 행은 해당 열의 값을 포함해야 하며 null 값은 허용되지 않는다.
- DEFAULT value : 값이 전달되지 않을 떄 추가되는 기본값 설정
- UNSIGNED : type이 숫자인 경우만 해당, 숫자가 0 또는 양수로 제한
- AUTO INCREMENT : 새 레코드가 추가될 때마다 필드 값을 자동으로 1 증가
- PRIMARY KEY : 테이블에서 행을 고유하게 식별하기 위해 사용

# 테이블 생성 제약 조건
테이블 생성시 컬럼에 직접 지정, CONSTRAINT로 지정, 또는 ALTER를 이용하여 설정 가능
- NOT NULL : 컬럼에 null 값을 저장할 수 없고, 반드시 쿼리문을 이용하여 값을 지정
- UNIQUE : 컬럼에 중복된 값을 저장할 수 없다. NULL 값은 허용
- PRIMARY KEY : 컬럼에 중복된 값 저장할 수 없다 NULL 값도 허용되지 않는다. 행을 구분하기 위한 유일한 값을 지정할 때 사용
- FOREIGN KEY : 특정 테이블의 PK 컬럼에 저장되어 있는 값만 저장, 참조키, 외래키, NULL 값 허용, references를 이용하여 어떤 컬럼에 어떤 데이터를 참조하는지 반드시 지정
- DEFAULT : NULL 값이 들어올 경우 기본 설정되는 값을 지정
- CHECK : 값의 범위나 종류를 지정(MYSQL 8.0.16 이후 버전)

# SELECT
```sql
SELECT col_name1, col_name2, ..
FROM table_name
WHERE ..
ORDER BY ..
```

# WHERE
- AND, OR, NOT
- IN, ANY, ALL
- `WHERE col_name IN (value1, value2, ..)`
- `WHERE col_name >= 6000 AND col_name <= 10000` ==  `WHERE col_name BETWEEN 6000 AND 10000`
- `WHERE col_name IS NULL`, `WHERE col_name IS NOT NULL`
- `WHERE col_name LIKE '%x%'`, `WHERE col_name LIKE 'x__'`

# 논리 연산
- `NOT NULL` => NULL

- `TURE AND NULL` => NULL
- `NULL AND FALSE` => FALSE
- `NULL AND NULL` => NULL

- `TURE OR NULL` => TRUE
- `FALSE OR NULL` => NULL
- `NULL OR NULL` => NULL

# ORDER BY
- `ORDER BY col_name ASC(DESC)`, default값으 ASC(오름차순)
- `ORDER BY col_name1, col_name2 DESC`, col_name으로 오름차순 정렬 후 col_name2 내림차순 정렬

# aggregation function
- SUM() : 그룹의 누적 합계 반환
- AVG() : 그룹의 평균을 반환, 소숫점 2자리까지
- COUNT() : 그룹의 총 개수를 반환
- MAX() : 그룹의 최댓값을 반환
- MIN() : 그룹의 최솟값을 반환

# GROUP BY
쿼리된 테이블의 행을 그룹으로 묶는다.
집계 함수를 각 행 그룹에 적용하고 각 그룹에 대해 단일 결과 행을 반환
GROUP BY 절을 생략하면 선택 목록의 집계함수를 쿼리된 테이블의 모든 행에 적용
SELECT 절의 모든 요소는 GROUP BY 절의 표현식, 집계 함수를 포함하는 표현식 또는 상수만 가능

```sql
SELECT columns              실행순서 5
FROM table_name             실행순서 1
WHERE conditions            실행순서 2
GROUP BY grouping columns   실행순서 3
HAVING grouping conditions  실행순서 4
ORDER BY col [ASC | DESC]   실행순서 6
```

WHERE 절이 GROUP BY 절보다 먼저 실행되기 때문에 aggregate 조건은 HAVING 절에 작성

# transaction
- START TRANSACTION : COMMIT, ROLLBACK 이 나올 때까지 실행되는 모든 SQL
- COMMIT : 모든 코드를 실행
- ROLLBACK : START TRANCATION 실행 전 상태로 되돌림
- SAVEPOINT savepoint_name : savepoint_name 세이브포인트 지정
- ROLLBACK savepoint_name : savepoint_name 상태로 ROLLBACK

# JOIN
둘 이상의 테이블에서 데이터가 필요한 경우 테이블 조인이 필요
일반적으로 조인조건을 포함하는 WHERE 절을 작성
조인 조건은 일반적으로 각 테이블의 PK 및 FK로 구성

조인의 처리는 어느 테이블을 먼저 읽을지를 결정하는 것이 중요(처리할 작업량이 상당히 달라진다.)
- INNER JOIN : 어느 테이블을 먼저 읽어도 결과가 달리지지 않는다. MySQL 옵티마이저가 조인 순서를 조절해서 다양한 방법으로 최적화를 수행할 수 있다.
- OUTER JOIN : 반드시 OUTER가 되는 테이블을 먼저 읽어야 하므로 옵티마이저가 조인 순서를 선택할 수 없다.

# INNER JOIN
가장 일반적인 JOIN 종류, 교집합
동등 조인(Equi - JOIN)이라고도 하며, N개의 테이블 조인 시 N-1개의 조인 조건이 필요

```sql
SELECT col1, col1, ..
FROM table1 INNER JOIN table2
ON table1.col = table2.col;     # 조인 조건은 ON, 일반 조건은 WHERE 
```

```sql
SELECT col1, col2, ...
FROM table1 JOIN table2
USING (공통 column);            # USING 절에서 table 이름이나 alias를 명시하면 error 발생
```

# OUTER JOIN
LEFT OUTER JOIN, RIGHT OUTER JOIN, FULL OUTER JOIN 으로 구분
어느 한 쪽 테이블에는 해당하는 데이터가 존재하는데 다른 쪽 테이블에는 데이터가 존재하지 않을 경우 그 데이터가 검색되지 않는 문제점을 해결하기 위해 사용

```sql
SELECT col1, col2, ...
FROM table1 LEFT OUTER JOIN table2      # 왼쪽 테이블을 기준으로 JOIN 조건에 일치하지 않는 데이터까지 출력
[ON ... | USING ... ];
```

```sql
SELECT col1, col2, ...
FROM table1 RIGHT OUTER JOIN table2     # 오른쪽 테이블을 기준으로 JOIN 조건에 일치하지 않는 데이터까지 출력 
[ON ... | USING ... ];
```

```sql
SELECT col1, col2, ..
FROM table1 FULL OUTER JOIN table2      # 양쪽 테이블을 기준으로 JOIN 조건에 일치하지 않는 데이터까지 출력, MySQL은 지원하지 않는다.
[ON ... | USING ...];
```

# SELF JOIN

```sql
SELECT alias1.col1, alias.col2, ...
FROM table1  alias1 INNER JOIN tabl1 alias2     # 같은 테이블끼리 JOIN
ON ...
```

# None-Equi JOIN
table의 PK, FK가 아닌 일반 column을 JOIN 조건으로 지정

# 서브쿼리
다른 쿼리 내부에 포함되어 있는 SELECT 문
서브 쿼리를 포함하고 있는 쿼리를 외부 쿼리(outer query) 또는 메인 쿼리라고 부르며,
서브 쿼리는 내부 쿼리(inner query)라고도 부른다.
서브 쿼리는 비교 연산자의 **오른쪽**에 기술해야하고 반드시 **괄호 ()**로 감싸져 있어야 한다.

서브 쿼리 종류
- 중첩 서브 쿼리(Nested SubQuery) : WHERE 문에 작성하는 서브 쿼리
  - 단일행, 다중행, 다중컬럼
- 인라인 뷰(Inline View) : FROM 문에 작성되는 서브 쿼리
  - 뷰 처럼 결과가 동적으로 생성된 테이블로 사용 가능
  - 임시적인 뷰로 데이터베이스에 저장되지 않는다.
  - 동적으로 생성된 테이블로 column을 자유롭게 참조 가능
- 스칼라 서브 쿼리(Scalar Subquery) : SELECT 문에 작성하는 서브 쿼리
  - 단일 행 반환

주의 사항
- 반드시 ()로 감싸야 한다.
- 단일 행 또는 다중 행 비교 연산자와 함께 사용된다.

서브 쿼리가 사용 가능한 곳
- SELECT
- FROM
- WHERE
- HAVING
- ORDER BY
- INSERT 문의 VALUES
- UPDATE 문의 SET

# View
하나의 테이블 혹은 여러 테이블에 대하여 특정 사용자나 조직의 관점에서 데이터를 바라볼 수 있도록 해주는 수단

뷰에 대해서도 행 추가 수정, 삭제 가능
단, 기존 테이블의 무결성 규칙을 만족한다면 실행, 문제가 된다면 실행되지 않는다.

가상 테이블
- 일반 테이블 : 실제로 물리적인 데이터를 갖고 있음
- View : 물리적인 데이터를 갖고 있지 않고, 뷰가 이미 정의된 테이블로부터 데이터를 가져다 보여줌

```sql
CREATE VIEW view_name AS
SELECT ...
FROM ...
```

# WHERE 절에는 별칭을 사용할 수 없다.
```sql
SELECT employee_id AS id, first_name AS name, salary AS sal
FROM employees
WHERE sal > 2000;
```

# 1
```sql
SELECT employee_id, first_name
FROM employees
WHERE first_name like 'Ste___';
```

# 2, 1과 2는 다른 결과
```sql
SELECT employee_id, first_name
FROM employees
WHERE substr(frist_name, 1, 3) = 'Ste';
```

# 3, 2와 3은 같은 결과
```sql
SELECT employee_id, first_name
FROM employees
WHERE first_name LIKE 'Ste%';
```

# 다른결과, \% => % 문자 자체 검색
```sql
SELECT employee_id, first_name
FROM employees
WHERE first_name LIKE 'Ste\%';
```

# 직원은 존재, 부서는 존재x, 항상 같은 경우만 조회는 x
# 직원테이블(left) 기준으로 조인, 직원테이블 데이터가 없으면 부서테이블이 있어도 조회 X
# 직원테이블 부서번호 기준으로 부서테이블 데이터가 없더라도 조회한다.
# CREAT VIEW 뷰이름 AS
```sql
SELECT d.department_id. d.department_name, e.first_name
FROM employees e LEFT JOIN department d
ON e.department_id = d. department.id;
```

```sql
SELECT *
FROM 뷰이름;
```

# 데이터의 양이 많고 조회를 많이 할 경우
# DML 작업이 많은 컬럼인 경우 - index를 적용하면 성능이 떨어진다.
# 변경이 자주 일어나는 컬럼에는 index를 잘 적용하지 않는다. 변경시 인덱스 역시 수정 필요 발생 가능

## 테이블 생성 이후 primary key 추가
```sql
ALTER TABLE employees ADD CONSTRAINT emp_pk PRIMARY KEY (employee_id);
```

# SUM(salary) 기준 내림차순 정렬
```sql
SELECT job_id, SUM(salary) sum
FROM employees
GROUP BY job_id
ORDER BY sum DESC;
```
# 띄어쓰기가 있으면 `` 백틱으로 참조

# mybatis
sqlSession
sqlSession.selectOne("select", dto);
sqlSession.selectList("selectAll", dto);

mapper.xml
resultType 속성은 select에서만 사용 가능

SimpleDriverDataSource - SqlSessionFactory - SqlSession

# 11/7(월) 9회차 DB & MyBatis 준비
MyBatis 
  - 객체와 메서드 (SqlSession이 가진 메서드)
  - 구성파일
  - 태그들과 태그 속성 (sql, selectKey 포함)
  - 동적쿼리 태그
  - MySql DB, Spring, MyBatis기반 프로젝트를 위한 dependency 종류
테이블 제약조건
  - PK, FK 의 개념 및 설정이유: 데이터의 무결성
  - 제약사항 종류
index 특징, view 특징, 사용법
SELECT
  - 실행순서
  - 연산자 (like, in, not in, is null, is not null 등)
  - 서브쿼리 사용 불가 위치
JOIN
  - 종류 , 사용방법
DDL 
  - 종류와 활용
  - create table 테이블명 (컬럼명 제약사항)
트랜잭션 
그룹함수