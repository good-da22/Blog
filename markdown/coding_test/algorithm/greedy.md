## 탐욕(Greedy) 알고리즘

<br>

탐욕 알고리즘은 최적해를 구하는데 사용되는 근시안적 방법

**최적화 문제(optimization)**란 가능한 해들 중에서 가장 좋은(최대 or 최소) 해를 찾는 문제

일반적으로, 머리 속에 떠어르는 생각을 검증 없이 바로 구현하면 **Greedy 접근**이 된다.

여러 경우 중 하나를 선택할 때 마다 그 순간에 최적이라고 생각 되는 것을 선택해 나가는 방식으로 진행, 최종적인 해답에 도달

각 선택 시점에서 이루어지는 결정은 **지역적으로는 최적이지만**

그 선택들은 계속 수집하여 최종적인 해답을 만들었다고 하여, **그것이 최적이라는 보장은 없다.** - **검증 요구**

일단, 한**번 선택된 것은 번복하지 않는다.** 이런 특성 때문에 대부분의 탐욕 알고리즘들은 단순하며, 또한 제한적인 문제들에 적용된다.

<br><br>

### 예제

<br>

#### 배낭 짐싸기(Knapsack)

<br>

$S = [item_1, item_2, ... , item_n]$, 물건들의 집합

$w_i$ : $item_i$의 무게

$P_i$ : $item_i$의 값

$W$ : 배낭이 수용 가능한 총 무게

<br>

제한된 무게내에서 선택한 물건의 합이 최대가 되도록 하는 문제

<br>

**0-1 Knapsack**
- 배낭에 물건을 통째로 담아야 하는 문제
- 물건을 쪼갤 수 없는 경우

<br>

완전 검색으로 물건들의 집합 S에 대한 모든 부분집합을 구한다.

부분집합의 총 무게가 W를 초과하는 집합들은 버리고, 나머지 집합에서 총 값이 가장 큰 집합을 선택

물건의 개수가 증가하면 시간 복잡도가 지수적으로 증가

크기가 n 인 부분집합의 수 $2^n$

<br>

**Fractional Knapsack**
- 물건을 부분적으로 담는 것이 허용되는 문제
- 물건을 쪼갤 수 있는 경우

<br>

단위 무게당 값이 제일 큰 것을 담는다.

<br><br>

### 활동 선택(Activity-selection problem) 문제

<br>

회의실 배정 문제

시작시간과 종료시간 $(s_i, f_i)$ 가 있는 n개의 활동의 집합 $A = A[A_1, A_2, ... , A_n]$ 에서 서로 겹치지 않는(non overlapping) 최대갯수의 활동들의 집합 $S$를 구하는 문제

<br>

양립 가능한 활동들의 크기가 최대가 되는 $S_{0, n+1}$의 부분집합을 선택하는 문제

1. **종료 시간** 순으로 활동을 정렬
2. 첫 번째 활동($A_1$) 을 선택
3. 선택한 활동($A_1$)의 종료시간보다 빠른 시작 시간을 가지는 활동은 무시(skip)하며 같거나 늦은 시작시간을 갖는 활동을 선택
4. 선택된 활동의 종료시간을 기준으로 뒤에 남은 활동들에 대해 앞의 과정을 반복

<br><br>

### 탐욕적 선택 속성(greedy choice property)

<br>

탐욕적 선택은 최적해로 갈 수 있음을 보여라 -> 즉, 탐욕적 선택은 항상 안전하다.

<br>

### 최적 부분 구조(optimal substructure property)

최적화 문제를 정형화하라 -> 하나의 선택을 하면 풀어야 할 하나의 하위 문제가 남는다

<br>

**원 문제의 최적 해 = 탐욕적 선택 + 하위 문제의 최적해** -> 임을 증명하라

<br>

### 대표적인 탐욕 기법의 알고리즘

<br>

**Prim**

n개의 노드에 대한 최소 신장 트리(MST)를 찾는다.

서브트리를 확장하면서 MST를 찾는다.

<br>

**Kruskal**

n개의 노드에 대한 최소 신장 트리(MST)를 찾는다.

싸이클이 없는 서브 그래프를 확장하면서 MST를 찾는다.

<br>

**Dijikstra**

주어진 정점에서 다른 정점들에대한 최단 경로를 찾는다.

주어진 정점에서 가장 가까운 정점을 찾고, 그 다음 올 정점을 반복해서 찾는다.