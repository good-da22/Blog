## 메모이제이션 (Memoization)

<br>

메모이제이션은 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술

동적 계획법의 핵심이 되는 기술

<br>

피보나치 수를 구하는 알고리즘에서 fibo(n)의 값을 계산하자마자 저장하면(memoize)

실행시간을 O(n)으로 줄일 수 있다.

```
memo를 위한 배열을 할당, 모두 0으로 초기화
memo[0]을 0으로 memo[1]는 1로 초기화

fibo(n)
    if n >= 2 AND memo[n] == 0
        memo[n] = fibo(n-1) + fibo(n-2)
    
    return memo[n]
```

<br>

추가적인 메모리 공간이 필요

재귀 함수 호출로 인한 시스템 호툴 스택을 사용, 실행 속도 저하 또는 오버플로는 발생 가능

<br>

## 동적 계획법 (Dynamic Programming)

<br>

그리디 알고리즘과 같이 **최적화 문제**를 해결하는 알고리즘

작은 부분 문제들의 해들을 구하고 이들을 활용하여 보다 큰 크기의 부분 문제들을 해결

최종적으로 원래 주어진 문제를 해결하는 알고리즘 설계 방법

**동적 계획법을 적용하려는 문제의 요건**
- 중복 부분문제 구조(Overlapping subproblems)
- 최적 부분문제 구조(Optimal substructure)

<br>

### 중복 부분문제 구조 (Overlapping subproblems)

<br>

DP는 큰 문제를 이루는 작은 문제들을 먼저 해결하고 작은 문제들의 최적 해(Optimal Solution)를 이용하여 순환적으로 큰 문제를 해결

순환적인 관계(recurrence relation)를 명시적으로 표현하기 위해서 동적 계획법에서는 일반적으로 수학적 도구인 점화식을 사용

DP는 문제의 순환적인 성질 때문에 이전에 계산되어졌던 작은 문제의 해가 다른 어딘가에서 필요(Overlapping subproblems)

이를 위해서 DP에서는 이미 해결된 작은 문제들의 해들을 어떤 저장 공간(table)에 저장하게 된다.

저장된 해들이 다시 필요할 때 마다 해를 얻기 위해서 다시 문제를 재계산하지 않고 table의 참조를 통해서 중복된 계산을 피하게 된다.

<br>

### 최적 부분문제 구조(Optimal substructure)

<br>

동적 계획법이 최적화에 대한 어느 문제에나 적용될 수 있는 것은 아니다.

주어진 문제가 최적화의 원칙(Principle of Optimality)을 만족해야만 동적 계획법을 효율적으로 적용할 수 있다.

어떤 문제에 대한 해가 최적일 때 그 해를 구성하는 작은 문제들의 해 역시 최적이어야 한다.

동적 계획법은 큰 문제의 최적 해를 작은 문제의 최적해들을 이용하여 구하는 형태

큰 문제의 최적해가 작은 문제들의 최적해들로 구성되지 않는다면 이 문제는 동적 계획법을 적용할 수 없다.

ex) 최장 경로 문제는 DP로 해결할 수 없다.

<br>

### 분할 정복과 동적 계획법의 비교

<br>

분할 정복
- 연관 없는 부분 문제로 분할
- 부분 문제를 재귀적으로 해결
- 부분 문제의 해를 결함(combine)
- ex) 병합 정렬, 퀵 정렬

동적 계획법
- 부분 문제들이 연관이 없으면 적용할 수 없다.
- 부분 문제들은 더 작은 부분 문제들을 공유한다.
- 모든 부분 문제를 한 번만 계산하고 결과를 저장하고 재사용

동적 계획법에는 부분 문제들 사이에 의존적 관계가 존재

관계는 문제에 따라 다르고, 대부분의 경우 뚜렷이 보이지 않아서 함축적인 순서(implicit order)라고 한다.

분할 정복은 하향식 방법으로 동적 계획벅은 **상향식 방법**으로 접근

<br>

### 3단계 동적 계획법 적용 접근 방법

<br>

1. 최적해 구조의 특성을 파악
   - 문제를 부분 문제로 나눈다.
2. 최적해의 값을 재귀적으로 정의
   - 부분 문제의 최적해 값에 기반하여 문제의 최적해 값을 정의
3. 상향식 방법으로 최적해의 값을 계산
   - 가장 작은 부분 문제부터 해를 구한 뒤 테이블에 저장
   - 테이블에 저장되어 있는 부분 문제의 해를 이용하여 점차적으로 상위 부분 문제의 최적해를 구한다(상향식 방법)

<br>

### 피보나치 수 DP 적용

<br>

피보나치 수는 부분 문제의 답으로부터 본 문제의 답을 얻을 수 있으므로 최적 부분 구조로 이우러져 있다.

1. 문제를 부분 문제로 분할
2. 점화식으로 정의
3. 가장 작은 부분 문제부터 해를 구한다. 결과를 테이블에 저장, 저장된 부분 문제의 해를 이용하여 상위 문제의 해를 구한다.

```
fibo_dp(n)
    f[0] = 0
    f[1] = 1

    FOR i in (2, n)
        f[i] = f[i-1] + f[i-2]
    
    return f[n]
```

DP 알고리즘이 수행속도가 더 빠르다
- 재귀 알고리즘과는 달리 중복 계산이 없다
- 반복문을 사용하기 때문에 함수 호출이 발생하지 않는다.

계산하는 항(fibo_dp(n))의 총 개수
- n + 1 개수의 항 계산
- 즉, fibo_dp[0] 부터 fibo_dp[n]까지 단 한 번씩만 계산
